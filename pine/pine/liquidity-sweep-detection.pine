//@version=6
indicator("Liquidity + Clean High/Low Levels + Trend Breakout + TP/SL", overlay=true, max_lines_count=500, max_labels_count=500)

// === LABEL COLOR INPUTS ===
set1LabelColor = input.color(color.gray, "Set 1 Label Color")

// === OTHER INPUTS ===
lengthGroupTitle = "LENGTH LEFT / RIGHT"
leftLenH = input.int(title="Pivot High Left", defval=10, minval=1, inline="Pivot High", group=lengthGroupTitle)
rightLenH = input.int(title="/", defval=10, minval=1, inline="Pivot High", group=lengthGroupTitle)
leftLenL = input.int(title="Pivot Low Left", defval=10, minval=1, inline="Pivot Low", group=lengthGroupTitle)
rightLenL = input.int(title="/", defval=10, minval=1, inline="Pivot Low", group=lengthGroupTitle)

mainHighColor = input.color(color.green, "Main High Color")
mainLowColor  = input.color(color.red,   "Main Low Color")
mainWidth     = input.int(title="Main Line Width", defval=1)

boxExtend = input.int(title="Box Extension Length (bars)", defval=10)
showBoxes = input.bool(true, "Show Breakout Boxes?")
showLabels = input.bool(true, "Show High/Low Labels?")
showSpecialFVGLabels = input.bool(true, "Show Special FVG Labels?")
minRatioThreshold = input.float(1.0, title="Minimum Ratio to Show Label")
triangleLookbackBars = input.int(10, "TP Lookback Bars", minval=1)

maxBarsToWaitFVG = input.int(5, "Max Bars to Wait for FVG", minval=1)

takeProfitColor = input.color(color.aqua,  "TP Line Color")
stopLossColor   = input.color(color.orange, "SL Line Color")
tpMultiplier    = input.float(0.764, "TP Multiplier (Fibonacci 0.764)", minval=0)
slPercent       = input.float(1.0, "SL Percent Stretch", minval=0)

// NEW: how many bars to hold the FVG state plot
fvgHoldBars = input.int(10, "FVG State Hold Bars", minval=1)

// === NEW: timeout highlight controls ===
highlightTimeouts = input.bool(true, "Highlight FVG Timeouts?")
timeoutTransp     = input.int(70, "Timeout Highlight Transparency (0-100)", minval=0, maxval=100)

// === NEW: minimum move required (percent) at timeout to allow highlight ===
timeoutMovePct = input.float(0.5, "Timeout Min Move %", minval=0.0, step=0.1)

// === PIVOTS ===
ph = ta.pivothigh(high, leftLenH, rightLenH)
pl = ta.pivotlow (low,  leftLenL, rightLenL)

// === ARRAYS ===
var line[]  highRays   = array.new_line()
var line[]  lowRays    = array.new_line()
var float[] highLevels = array.new_float()
var float[] lowLevels  = array.new_float()

// === SIGNAL PLOT ===
var int labelSignal = 0
labelSignal := 0

// === TP/SL State Memory ===
var float tpLast = na
var float slLast = na
var int   slStartBar = na

plot(tpLast, title="TP Level", color=takeProfitColor, linewidth=2)
plot(slLast, title="SL Level", color=stopLossColor, linewidth=2)

// === RAY DRAWING ===
if not na(ph)
    array.push(highRays, line.new(bar_index[rightLenH], ph, bar_index + 500, ph, extend=extend.right, color=mainHighColor, width=mainWidth))
    array.push(highLevels, ph)
if not na(pl)
    array.push(lowRays, line.new(bar_index[rightLenL], pl, bar_index + 500, pl, extend=extend.right, color=mainLowColor, width=mainWidth))
    array.push(lowLevels, pl)

var bool highBreak = false
var bool lowBreak  = false
highBreak := false
lowBreak  := false

// === SPECIAL FVG TRACKING ===
var bool   specialFVGPlotted = false
var int    lastBreakBar      = na
var string lastBreakType     = ""  // "high" or "low"
var float  lastBoxTop        = na
var float  lastBoxBottom     = na
var float  breakRefPrice     = na  // NEW: reference price at break for timeout move calc

// === MAIN SET BREAKOUT ===
if array.size(highRays) > 0 and array.size(highLevels) > 1 and array.size(lowLevels) > 0
    // emulate reverse loop with positive step
    for idx = 0 to array.size(highRays) - 1
        i = array.size(highRays) - 1 - idx
        level = array.get(highLevels, i)
        if high > level
            breakoutPrice = high
            float nearestHigh = na
            float nearestLow  = na
            // nearest high
            for j = 0 to array.size(highLevels) - 1
                if j != i
                    tempLevel = array.get(highLevels, j)
                    dist = math.abs(tempLevel - breakoutPrice)
                    nearestHigh := na(nearestHigh) or dist < math.abs(nearestHigh - breakoutPrice) ? tempLevel : nearestHigh
            // nearest low
            for j = 0 to array.size(lowLevels) - 1
                tempLevel = array.get(lowLevels, j)
                dist = math.abs(tempLevel - breakoutPrice)
                nearestLow := na(nearestLow) or dist < math.abs(nearestLow - breakoutPrice) ? tempLevel : nearestLow

            denom = breakoutPrice - nearestLow
            numer = nearestHigh - breakoutPrice
            ratio = not na(numer) and not na(denom) and denom != 0 ? numer / denom : na
            if not na(ratio) and ratio >= minRatioThreshold
                if showLabels
                    label.new(bar_index, high, text=str.tostring(ratio, "#.##"), style=label.style_label_down, color=color.green)
                highBreak := true
                labelSignal := 1

                // TP calc (lookback lowest low)
                float lowestInLookback = low
                for j = 1 to triangleLookbackBars
                    lowestInLookback := math.min(lowestInLookback, low[j])
                tpDistance = close - lowestInLookback
                tpLast := close - tpDistance * tpMultiplier

                lastBreakBar  := bar_index
                lastBreakType := "high"
                slStartBar    := bar_index
                specialFVGPlotted := false
                lastBoxTop    := high
                lastBoxBottom := low
                breakRefPrice := breakoutPrice   // NEW
            else
                highBreak := false
                labelSignal := 0
            line.delete(array.get(highRays, i))
            array.remove(highRays, i)
            array.remove(highLevels, i)

if array.size(lowRays) > 0 and array.size(lowLevels) > 1 and array.size(highLevels) > 0
    // emulate reverse loop with positive step
    for idx = 0 to array.size(lowRays) - 1
        i = array.size(lowRays) - 1 - idx
        level = array.get(lowLevels, i)
        if low < level
            breakoutPrice = low
            float nearestLow  = na
            float nearestHigh = na
            // nearest low
            for j = 0 to array.size(lowLevels) - 1
                if j != i
                    tempLevel = array.get(lowLevels, j)
                    dist = math.abs(tempLevel - breakoutPrice)
                    nearestLow := na(nearestLow) or dist < math.abs(nearestLow - breakoutPrice) ? tempLevel : nearestLow
            // nearest high
            for j = 0 to array.size(highLevels) - 1
                tempLevel = array.get(highLevels, j)
                dist = math.abs(tempLevel - breakoutPrice)
                nearestHigh := na(nearestHigh) or dist < math.abs(nearestHigh - breakoutPrice) ? tempLevel : nearestHigh

            denom = nearestHigh - breakoutPrice
            numer = breakoutPrice - nearestLow
            ratio = not na(numer) and not na(denom) and denom != 0 ? numer / denom : na
            if not na(ratio) and ratio >= minRatioThreshold
                if showLabels
                    label.new(bar_index, low, text=str.tostring(ratio, "#.##"), style=label.style_label_up, color=color.red)
                lowBreak := true
                labelSignal := -1

                // TP calc (lookback highest high)
                float highestInLookback = high
                for j = 1 to triangleLookbackBars
                    highestInLookback := math.max(highestInLookback, high[j])
                tpDistance = highestInLookback - close
                tpLast := close + tpDistance * tpMultiplier

                lastBreakBar  := bar_index
                lastBreakType := "low"
                slStartBar    := bar_index
                specialFVGPlotted := false
                lastBoxTop    := high
                lastBoxBottom := low
                breakRefPrice := breakoutPrice   // NEW
            else
                lowBreak := false
                labelSignal := 0
            line.delete(array.get(lowRays, i))
            array.remove(lowRays, i)
            array.remove(lowLevels, i)

// === SPECIAL FVG LINES & TIMEOUT ===
alertBullish = false
alertBearish = false

// Per-bar local timeout highlight (resets automatically each bar)
bool  isTimeoutBar  = false
color timeoutColor  = na

if bar_index >= 2 and barstate.isconfirmed
    fvgBullish = low - high[2] > 0
    fvgBearish = high - low[2] < 0

    // A) Valid FVG forms within window
    if not specialFVGPlotted and not na(lastBreakBar) and showSpecialFVGLabels
        price = close
        if lastBreakType == "high" and fvgBearish
            percentDiff = price > lastBoxTop ? -math.abs((price - lastBoxTop) / price) * 100 : price < lastBoxBottom ? math.abs((lastBoxBottom - price) / price) * 100 : 0
            if percentDiff >= 0
                line.new(x1=bar_index, y1=low - 1000, x2=bar_index, y2=high + 1000, color=color.red, style=line.style_solid, width=1, extend=extend.none)
                float maxHigh = high
                for i2 = slStartBar to bar_index
                    maxHigh := math.max(maxHigh, high[bar_index - i2])
                slDistance = close - maxHigh
                slLast := close - slDistance * (1 + slPercent)
                specialFVGPlotted := true
                alertBearish := true

        if lastBreakType == "low" and fvgBullish
            percentDiff = price < lastBoxBottom ? -math.abs((lastBoxBottom - price) / price) * 100 : price > lastBoxTop ? math.abs((price - lastBoxTop) / price) * 100 : 0
            if percentDiff >= 0
                line.new(x1=bar_index, y1=low - 1000, x2=bar_index, y2=high + 1000, color=color.green, style=line.style_solid, width=1, extend=extend.none)
                float minLow = low
                for i2 = slStartBar to bar_index
                    minLow := math.min(minLow, low[bar_index - i2])
                slDistance = minLow - close
                slLast := close + slDistance * (1 + slPercent)
                specialFVGPlotted := true
                alertBullish := true
                alert("Special FVG Bullish Formed", alert.freq_once_per_bar_close)

    // B) Window EXPIRES with NO corresponding FVG -> allow one-bar highlight ONLY if min move met
    if highlightTimeouts and not specialFVGPlotted and not na(lastBreakBar) and not na(breakRefPrice)
        barsSinceBreak = bar_index - lastBreakBar
        if barsSinceBreak == maxBarsToWaitFVG
            movedEnough = false
            if lastBreakType == "high"
                // need UP move >= timeoutMovePct
                movePctUp = ((close - breakRefPrice) / breakRefPrice) * 100.0
                movedEnough := movePctUp >= timeoutMovePct
                if movedEnough
                    isTimeoutBar := true
                    timeoutColor := color.new(color.green, timeoutTransp)
            else if lastBreakType == "low"
                // need DOWN move >= timeoutMovePct
                movePctDown = ((breakRefPrice - close) / breakRefPrice) * 100.0
                movedEnough := movePctDown >= timeoutMovePct
                if movedEnough
                    isTimeoutBar := true
                    timeoutColor := color.new(color.red, timeoutTransp)
            // close this cycle regardless to avoid repeats
            specialFVGPlotted := true

// Apply EXACTLY one-bar timeout highlight
bgcolor(isTimeoutBar ? timeoutColor : na)

// === Alerts ===
alertcondition(alertBullish, title="Bullish Special FVG", message="Special FVG Bullish Formed")
alertcondition(alertBearish, title="Bearish Special FVG", message="Special FVG Bearish Formed")

// === FVG state (1 bull, -1 bear) with hold timer ===
var int fvgState = 0
var int fvgHold  = 0
if alertBullish
    fvgState := 1
    fvgHold  := fvgHoldBars
else if alertBearish
    fvgState := -1
    fvgHold  := fvgHoldBars
else
    if fvgHold > 0
        fvgHold -= 1
    else
        fvgState := 0

plot(fvgState, title="FVG State (1 bull / -1 bear / 0 none)", color=fvgState > 0 ? color.new(color.green, 0) : fvgState < 0 ? color.new(color.red, 0) : color.new(color.gray, 60), linewidth=2)

// === FINAL SIGNAL PLOT ===
plot(labelSignal, title="High/Low Signal", color=color.new(color.yellow, 0), style=plot.style_columns, linewidth=2)
